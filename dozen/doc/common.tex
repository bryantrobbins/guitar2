%
% Common scripts
%
\subsection{Common scripts}

\mddozen{} includes a set of scripts. The scripts are used for deploying GUITAR on a testbed, configuring AUTs, ripping AUTs, generating and executing testcases on the AUT. These scripts are called \textit{common} scripts since they are common to all the AUTs. The common scripts are placed in the directory \texttt{common/} (see Figure~\ref{fig:dozenlayout}).

The common scripts invoke GUITAR's tools to perform operations such as ripping, testcase generation and execution. They call GUITAR specific scripts locate in the GUITAR's tools directory (see Section~\ref{sec:tools}). 

\subsubsection{Overview}

The common scripts are divided into three categories:\\

\begin{smalldescription}
   \item [Local] Scripts that execute locally on a machine. They do not invoke another script on a remote machine. Note, that these scripts may run on a controller machine or may be invoked on a remote machine. These scripts contain the prefix \texttt{common}.

   \item [Cluster] Cluster scripts typically execute a process or test activity on one or more remote machines. They may invoke a \textit{local} script on a remote machine. The cluster scripts contain the prefix \texttt{cluster}.

   \item [Utilities] Utility scripts contain miscellaneous functions such as virtual screen configuration, rsync and ssh wrappers. They contain the prefix \texttt{util}.
\end{smalldescription}


\subsubsection{Description}

\textbf{Local} scripts accept the name of one AUT as a command line argument. The name must be same as the $<$aut-name$>$ specified in the \texttt{auts/<aut-name>} directory structure. The local scripts are described here.\\

\begin{smalldescription}
\label{sec:commondescription}

   \item [common-init-dir.sh] Creates a directory structure\\ \texttt{auts/<aut-name>/\{[aut/], [aut/src/], [aut/bin/], } \texttt{[aut/inst/], [models/], [testsuites]\} } (see Figure~\ref{fig:autlayout}).

   \item [common-checkout.sh] Obtains an AUT from an external repository and stores it under \texttt{auts/<aut-name>/aut/src}. It invokes the AUT script \\ \texttt{auts/<aut-name>/scripts/aut.checkout.sh}.

   \item [common-build.sh] Builds an AUT from the source, obtained by \texttt{common-checkout.sh}, Places the built components in the directory \texttt{auts/<aut-name>/aut/bin}. It invokes the AUT script \\ \texttt{auts/<aut-name>/scripts/aut.build.sh}.

   \item [common-inst.sh] Instruments the binary bytecode generated by \texttt{common-build.sh}. The instrumented bytecode is placed in a directory \texttt{auts/<aut-name>/aut/inst}.

  \item [common-build-check.sh] Verifies that an AUT's built binaries and instrumented binaries are present after the build and instrumentation steps complete. This script simply uses the \texttt{aut\_bin\_check} list from the \texttt{aut.cfg} file and checks if those files are present.

   \item [common-rip.sh] Invokes GUITAR's ripper tool to rip the AUT and create a GUI tree. The invoked GUITAR script is \texttt{jfc-ripper.sh} (see Section~\ref{sec:tools}). The ripped GUI tree \texttt{<aut-name>.GUI} obtained by ripping is stored in the directory \\ \texttt{auts/<aut-name>/model}. \\
   The ripping process also generates a coverage file, containing the code coverage during the ripping process. This is stored in the location \texttt{auts/<aut-name>/models/ripping-coverage/}.

   \item [common-gui2efg.sh] Convert the ripped model into an event-flow graph (EFG). The EFG is stored in the same location as the GUI model as \texttt{<aut-name>.EFG}.

   \item [common-tc-gen-sq.sh] Generates sequential length coverage testcases from an EFG for a given AUT. The EFG, \texttt{<aut-name>.EFG}, is read from the \texttt{models/} directory. The testcases are placed in the directory \texttt{auts/<aut-name>/testsuites/sq\_l\_\underline{N}}, which is created by this script. \texttt{sq\_l\_\underline{N}} is the testsuite name for testcases of length $N$.
   \item [common-tc-gen-rand.sh] Similar to \texttt{common-tc-gen-sq.sh}. The testsuite name is \texttt{rand\_l\_\underline{N}} for testcases of length $N$.

   \item [common-replay.sh] Executes testcases on a local machine on a given AUT. Artifacts are generated and stored on the local machine in the directories \texttt{coverage/}, \texttt{logs/}, \texttt{oracles/} within the
   \texttt{testsuites/<testsuite-name>/} directory (see Figure~\ref{fig:autlayout}). These artifacts are then copied to a specified archive location on an archive machine. This script invokes the GUITAR replayer using the script \texttt{jfc-replayer.sh} (see Section~\ref{sec:tools}).\\

\end{smalldescription}

From the above description, it can be seen that results of testcase execution are stored in an \textit{archive machine} and \textit{archive path} in that machine. The archive follows a subset of the directory layout as the AUTs, as given in Figure~\ref{fig:autlayout}. See Section~\ref{sec:process} for details on post-processing the archived results. The archive path needs to be specified upto the \texttt{auts/} level, for example, \texttt{/archive/auts}. The archive directory structure will be created below this directory.

Table~\ref{table:localscripts} summarizes the local scripts, their command line arguments and other scripts invoked by them.\\

\begin{table*}
   \centering
   \scriptsize{
   \begin{tabular}{lll}
      \hline
      & & \\
      AUT                  & Invokes & Arguments  \\
      & & \\
      \hline
      & & \\
      common-init-dir.sh   & None                     & $<$aut-name$>$ \\
      & & \\
      common-checkout.sh   & AUT's aut.checkout.sh    & $<$aut-name$>$ \\
      & & \\
      common-build.sh      & AUT's aut.build.sh       & $<$aut-name$>$ \\
      & & \\
      common-inst.sh       & Cobertura's cobertura-inst.sh   & $<$aut-name$>$ \\
      & & \\
      common-rip.sh        & GUITAR's jfc-ripper.sh   & $<$aut-name$>$ $<$xvfb-tmp-dir$>$ $<$xvfb-lib-path$>$ $<$xvfb-cmd$>$ \\
      & & \\
      common-gui2efg.sh    & GUITAR's gui2efg.sh      & $<$aut-name$>$ $<$efg-type$>$ \\
      & & \\
      common-tc-gen-sq.sh  & GUITAR's tc-gen-sq.sh    & $<$aut-name$>$ $<$testcase-length$>$ $<$\# testcases$>$ \\
      & & \\
      common-replay.sh     & GUITAR's jfc-replayer.sh & $<$aut-name$>$ $<$.GUI-path$>$ $<$.EFG-path$>$ $<$testsuites-path$>$ $<$testsuite-name$>$ \\
                           &                          & $<$xvfb-tmp-dir$>$ $<$xvfb-lib-path$>$ $<$xvfb-cmd$>$ \\
                           & -                        & $<$archive-username$>$ $<$archive-hostname$>$ $<$archive-auts-dir$>$ \\
      & & \\
      \hline 
   \end{tabular}

   \begin{tabular}{rl}
   & \\
   $<$aut-name$>$            & AUT name, as present in the directory structure in Figure~\ref{fig:autlayout} \\
   $<$archive-username$>$    & Login name to use on the archive machine, for example, \texttt{jenkins} \\
   $<$archive-hostname$>$    & Machine name/IP of the archive machine, for example, \texttt{gandalf.cs.umd.edu} \\
   $<$archive-auts-dir$>$    & Archive path upto the \texttt{auts/} level on the archive machine, for example, \texttt{/archive/auts/} \\
   $<$efg-type$>$            & \texttt{new} or \texttt{old} \\
   $<$testcase-length$>$     & Length of event-sequence to generate as testcases, for example, \texttt{2} \\
   $<$\# testcases$>$         & Upper bound on testsuite size. \texttt{0} indicates all possible. \\
   $<$testsuite-name$>$      & Testsuite name only, for example, \texttt{sq\_l\_2} \\
   $<$xvfb-tmp-dir$>$        & Directory on cluster machines that \texttt{Xvfb} can use as scratch space, for example, \texttt{/tmp} \\
   $<$xvfb-lib-path$>$       & DIrectory on cluster machines where \texttt{Xvfb} libraries are stores, for example, \texttt{/usr/lib/X11} \\
   $<$xvfb-cmd$>$            & \texttt{Xvfb} binary location on cluster machines, for example, \texttt{/usr/bin/Xvfb}
   \end{tabular}

   }

   \caption{Scripts executed locally on controller machine or remote machine.}
   \label{table:localscripts}
\end{table*}

\noindent \textbf{Cluster} scripts execute a set of commands on a testbed. A testbed may consist of entities capable of replaying a testcase. Entities are one of the following 2 types:\\

\begin{smalldescription}
\item [user-login in a physical machine] In this type, a user login on a physical machine that is capable of replaying testcases. The user login may be on a machine that supports many such users.
\item [user-login in a virtual machine] In this type, a user login on a virtual machine that is capable of replaying testcases. The user login may be on a virtual machine that supports many such users.\\
\end{smalldescription}

Typically, \mddozen{} should be executed on a homogeneous cluster, that is, all user logins must be on an idential physical (or virtual) machine. This is because, the response of a GUI application may depend on hardware resources. A homogeneous cluster reduces the chance of differing GUI responses.

Cluster scripts typically accept, as command line argument, a \textit{host configuration file}. This file describes the testbed -- machine identfiers, working directory on the remote machines, login name etc.


Figure~\ref{fig:hostcfg} shows the example of a host configuration file. It is self explanatory, containing all required parameters. Machine identifiers in the host configuration file may be static names or IP addresses along with an optional port name.

The cluster scripts are executed on a controlled machine. The controller machine controls execution on the cluster. All cluster machine are typically homogeneous. However, the controller machine may be different from the cluster machines.

\begin{figure}
\scriptsize{
   \begin{lstlisting}[language=sh, showstringspaces=false, breaklines=true]
# GUITAR revision
guitar_revision=HEAD
checkout_type=num

#
# Default "Cluster user name" to be used for
# all remote hosts.
#
username="cluster"

#
# Cluster tmp directory location
# Multiple usernames on the same machine
# must have a unique location
#
tmpdir="./tester/"

# EFG Argument type
efg_arg_type="new"

# X11 configuration on cluster
x_lib_path="/usr/lib/X11"
cmd_xvfb="/usr/bin/Xvfb"

#
# Stage host name
# 
stage_host="bugs.cs.umd.edu:2201:tester1"

#
# List of all remote hosts on the cluster.
# This is specified using one of the following
# formats. Note the ":"s below.
#
# a) remote host is a physical machine
#    <host-name>::<remote-username>
#    <host-name>::
#
# b) remote host is a VM
#    <host-name>:<host-port>:<remote-username>
#    <host-name>:<host-port>:
#
# When <remote-username> is specified, it overrides
# the "Cluster user name" above. This format also
# applies to the "Stage host name".
#
host_list=(\
   "bugs.cs.umd.edu:2202:tester2"\
   "bugs.cs.umd.edu:2203:tester3"\
)
   \end{lstlisting}

}
   \caption{\texttt{mycluster.cfg} host configuration file used by cluster scripts.}
   \label{fig:hostcfg}
\end{figure}


The cluster scripts are as follows:\\

\begin{smalldescription}
   \item [cluster-test.sh] Tests if all machines in the cluster are alive and ssh-able. This implicitly tests if the \texttt{ssh} keys between the controller machine and the remote machine is working. The script may hang if the \texttt{ssh} keys are not working.

   \item [cluster-setup.sh] Configures a cluster to work as a testbed for a GUITAR experiment using a spefied AUT. This steps performed are:
   \begin{enumerate}
      \item checkout GUITAR and other tools on the staging machine and all cluster machines
      \item build GUITAR and other tools on staging machine and all cluster machines
      \item checkout AUT on staging machine
      \item build AUT on staging machine
      \item instrument AUT bytecode on staging machine
      \item rip AUT on staging machine
      \item convert ripped .GUI into .EFG on staging machine
      \item copy AUT bytecode, models from staging macine to controller machine
      \item copy AUT bytecode and models from controller machine to all machines on the cluster
      \item sanity check the copied files on all remote machines
   \end{enumerate}

   \item [cluster-tc-gen-\{rand, sq\}.sh] Generates testcases on the staging machine and stores them in the archive machine. Testcases are generated on the staging machine so that the environment is the same as other cluster machines.
   \begin{enumerate}
      \item steps 1--7 of \texttt{cluster-setup.sh}
      \item generate sequential/random testcases on staging machine
      \item archive testcases and model to archive location
   \end{enumerate}

   \item [cluster-tc-dist.sh] Copies testcases from a testsuite on the archive location to the cluster. The split testsuite directories (see \texttt{util-split-dir.sh}) are distributed across the cluster. The original testsuite directory is deleted. The original testsuite directory may need to be backed up.

   \item [cluster-replay.sh] Executes testcases on a cluster. Each machine on the cluster is assumed to have the testcases that it will execute. This script invokes \texttt{common-replay.sh} on each cluster machine to execute its test cases. The artifacts of the execution are stored on the archive machine.\\

\end{smalldescription}

Table~\ref{table:clusterscripts} shows the cluster scripts along with their command line arguments and scripts they invoke. This concludes the description of the common scripts. The common scripts deploy GUITAR and other tools on the controller and cluster machines. \\


\noindent \textbf{Utility} scripts implement functionality such as invoking \texttt{Xvfb}, \texttt{rsync}, \texttt{ssh} and shell commands.\\

\begin{smalldescription}
   \item [util-bunzip-untar.sh] \texttt{bunzip2} and un-\texttt{tar} a directory full of \texttt{*.tar.bz2} files. This script is used for uncompressing coverage files for analysis.

   \item [util-rsync.sh] Convenient wrapper for executing \texttt{rsync} command, particularly when the controller machne is not the source or destination of \texttt{rsync}. This command can be invoked on a source or destination machine by the controller.

   \item [util.sh] \texttt{bash} wrapper functions for start / stop \texttt{Xvfb}, \texttt{ssh} wrapper functions, \texttt{rsync} wrapper functions.

   \item [util-xvfb.sh] Script for start / stopping \texttt{Xvfb}.

   \item [util-users.sh] Script to create or delete a set of user logins on the machine where it is executed.

   \item [util-split-dir.sh] Split a directory full of testcases into multiple directories. These multiple directories will correspond to each machine on the testbed. Each directory full of testcases will be later transferred to a testbed machine for execution by \texttt{cluster-tc-dist.sh}. The original testsuite directory will be deleted and may need to be backed up by the user before running this script.
\end{smalldescription}


\begin{table*}
   \centering
   \scriptsize{
   \begin{tabular}{lll}
      \hline
      & & \\
      AUT                    & Invokes & Arguments  \\
      & & \\
      \hline
      & & \\
      cluster-test.sh        & None                     & $<$host-cfg$>$ \\
      & & \\
      cluster-setup.sh       & common-init-dir.sh common-checkout.sh common-build.sh
                                                        & $<$aut-name$>$ $<$host-cfg$>$ \\
                             & common-inst.sh common-rip.sh common-gui2efg.sh
                                                        & \\
      & & \\
      cluster-tc-gen-sq.sh   & common-init-dir.sh common-checkout.sh common-build.sh 
                                                        & $<$aut-name$>$ $<$host-cfg$>$ \\
                             & common-inst.sh common-rip.sh common-gui2efg.sh common-tc-gen-sq.sh
                                                        & $<$archive-username$>$ $<$archive-hostname$>$ $<$archive-auts-dir$>$ \\
                             & -                        & $<$testcase-length$>$ $<$\# testcases$>$ \\
      & & \\
      cluster-tc-gen-rand.sh & common-init-dir.sh common-checkout.sh common-build.sh 
                                                        & $<$aut-name$>$ $<$host-cfg$>$ \\
                             & common-inst.sh common-rip.sh common-gui2efg.sh common-tc-gen-rand.sh
                                                        & $<$archive-username$>$ $<$archive-hostname$>$ $<$archive-auts-dir$>$ \\
      & & \\
      cluster-tc-dist.sh     & None                     & $<$aut-name$>$ $<$host-cfg$>$ \\
                             &                          & $<$archive-username$>$ $<$archive-hostname$>$ $<$archive-auts-dir$>$ \\
                             &                          & $<$testsuite-name$>$ \\
      & & \\
      cluster-replay.sh      & common-replay.sh         & $<$aut-name$>$ $<$host-cfg$>$ \\
                             &                          & $<$archive-username$>$ $<$archive-hostlist$>$ $<$archive-auts-dir$>$ \\
                             &                          & $<$testsuite-name$>$ \\
      & & \\
      \hline
   \end{tabular}

   \begin{tabular}{rl}
   & \\
   $<$aut-name$>$            & AUT name, as present in the directory structure in Figure~\ref{fig:autlayout} \\
   $<$host-cfg$>$            & Path to cluster configuration file \\
   $<$testcase-length$>$     & Length of event-sequence to generate as testcases, for example, \texttt{2} \\
   $<$\# testcases$>$         & Upper bound on testsuite size. \texttt{0} indicates all possible. \\
   $<$archive-username$>$    & Login name to use on the archive machine, for example, \texttt{jenkins} \\
   $<$archive-hostname$>$    & Machine name/IP of the archive machine, for example, \texttt{gandalf.cs.umd.edu} \\
   $<$archive-auts-dir$>$    & Archive path upto the \texttt{auts/} level on the archive machine, for example, \texttt{/archive/auts/} \\
   $<$archive-hostlist$>$    & Archive machine name(s), separated with \textbf{:} \\
   $<$testsuite-name$>$      & Testsuite name only, for example, \texttt{sq\_l\_2}
  
   \end{tabular}

   }

   \caption{Scripts executed locally on controller machine that invoke testing activities on a cluster.}
   \label{table:clusterscripts}
\end{table*}
